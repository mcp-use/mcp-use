---
title: "Middleware System"
description: "Flexible middleware system for intercepting and processing MCP requests and responses"
icon: "layers"
---

The mcp-use middleware system provides a powerful, flexible way to intercept and process all MCP (Model Context Protocol) requests and responses. Using an Express.js-style callback pattern, middleware functions can perform logging, metrics collection, caching, rate limiting, and custom processing.

## Overview

Middleware in mcp-use follows a simple, familiar pattern where each middleware function receives:
- `request: MCPRequestContext` - The MCP request with metadata
- `call_next: NextFunctionT` - Function to call the next middleware or actual MCP handler

Each middleware function can process both incoming requests (before `call_next()`) and outgoing responses (after `call_next()`), making it naturally bidirectional.

## Quick Start

```python
from mcp_use import MCPClient
from mcp_use.middleware.logging import create_logging_middleware
from mcp_use.middleware.metrics import create_metrics_middleware

# Create middleware
logging_middleware = create_logging_middleware(detailed=True)
metrics_middleware, get_metrics = create_metrics_middleware()

# Custom middleware
async def custom_middleware(request, call_next):
    print(f"🚀 Starting {request.method}")
    result = await call_next()
    print(f"✅ Completed {request.method}")
    return result

# Use with MCPClient
client = MCPClient(
    config=config,
    middleware=[logging_middleware, metrics_middleware, custom_middleware]
)
```

## Core Types

### MiddlewareCallbackT Protocol

The main middleware function signature:

```python
from typing import Protocol
from mcp_use import MCPRequestContext, NextFunctionT

class MiddlewareCallbackT(Protocol):
    """Protocol for Express.js-style middleware callbacks."""

    async def __call__(self, request: MCPRequestContext, call_next: NextFunctionT) -> Any:
        ...
```

### MCPRequestContext

Contains all request information and metadata:

```python
@dataclass
class MCPRequestContext:
    id: str                              # Unique request ID
    method: str                          # MCP method (e.g., "tools/call")
    params: dict[str, Any]               # Request parameters
    connector_id: str                    # Connector identifier
    timestamp: float                     # Request start time
    metadata: dict[str, Any]             # Custom metadata
    jsonrpc_request: JSONRPCRequest | None = None  # Raw MCP request
```

### NextFunctionT Protocol

The function to call the next middleware:

```python
class NextFunctionT(Protocol):
    """Protocol for the next() function passed to middleware."""

    async def __call__(self) -> Any:
        ...
```

## Writing Middleware

### Basic Pattern

```python
from mcp_use.middleware import MCPRequestContext, NextFunctionT, MiddlewareCallbackT

async def my_middleware(request: MCPRequestContext, call_next: NextFunctionT) -> Any:
    # BEFORE: Process incoming request
    print(f"📥 Incoming: {request.method}")

    try:
        # Execute next middleware or actual MCP call
        result = await call_next()

        # AFTER: Process outgoing response
        print(f"📤 Outgoing: {request.method} -> {type(result)}")
        return result

    except Exception as e:
        # ERROR: Handle errors
        print(f"❌ Error in {request.method}: {e}")
        raise  # Re-raise to maintain error handling
```

### Advanced Middleware Examples

#### Request Timing Middleware

```python
import time

async def timing_middleware(request: MCPRequestContext, call_next: NextFunctionT) -> Any:
    start_time = time.time()

    result = await call_next()

    duration = time.time() - start_time
    print(f"⏱️ {request.method} took {duration:.3f}s")

    return result
```

#### Request Filtering Middleware

```python
async def filter_middleware(request: MCPRequestContext, call_next: NextFunctionT) -> Any:
    # Block certain methods
    if request.method in ["dangerous/operation"]:
        raise ValueError(f"Method {request.method} is not allowed")

    # Modify request parameters
    if request.method == "tools/call":
        request.metadata["filtered"] = True

    return await call_next()
```

#### Response Caching Middleware

```python
from functools import lru_cache
import json

# Simple in-memory cache
_cache = {}

async def caching_middleware(request: MCPRequestContext, call_next: NextFunctionT) -> Any:
    # Create cache key from method and params
    cache_key = f"{request.method}:{json.dumps(request.params, sort_keys=True)}"

    # Check cache
    if cache_key in _cache:
        print(f"🎯 Cache hit for {request.method}")
        return _cache[cache_key]

    # Execute request
    result = await call_next()

    # Cache result (for read-only operations)
    if request.method.startswith(("list_", "get_", "read_")):
        _cache[cache_key] = result
        print(f"💾 Cached result for {request.method}")

    return result
```

## Built-in Middleware

### Logging Middleware

<CodeGroup>

```python Basic Logging
from mcp_use.middleware.logging import create_logging_middleware

# Basic logging
logging_middleware = create_logging_middleware()

# Detailed logging with request/response data
detailed_logging = create_logging_middleware(detailed=True)
```

```python Structured Logging
from mcp_use.middleware.logging import create_structured_logging_middleware

# Structured JSON logging
structured_middleware = create_structured_logging_middleware(
    log_level="INFO",
    include_params=True,
    include_result=False,
    max_result_length=200
)
```

```python Conditional Logging
from mcp_use.middleware.logging import (
    create_tool_logging_middleware,
    create_conditional_logging_middleware
)

# Only log tool calls
tool_logger = create_tool_logging_middleware(detailed=True)

# Custom condition
custom_logger = create_conditional_logging_middleware(
    lambda req: "important" in req.method,
    detailed=True
)
```

</CodeGroup>

### Metrics Middleware

<CodeGroup>

```python Basic Metrics
from mcp_use.middleware.metrics import create_metrics_middleware

# Create metrics middleware and getter
metrics_middleware, get_metrics = create_metrics_middleware()

# Use with client
client = MCPClient(config=config, middleware=[metrics_middleware])

# Get metrics after requests
metrics = get_metrics()
print(f"Total requests: {metrics['total_requests']}")
print(f"Method counts: {metrics['method_counts']}")
print(f"Average durations: {metrics['method_avg_duration']}")
```

```python Performance Metrics
from mcp_use.middleware.metrics import create_performance_metrics_middleware

# Advanced performance tracking
perf_middleware, get_perf = create_performance_metrics_middleware()

# Get detailed performance stats
perf_stats = get_perf()
print(f"P95 latency: {perf_stats['method_performance']['tools/call']['p95']}ms")
print(f"Slow requests: {len(perf_stats['slow_requests'])}")
```

```python Combined Analytics
from mcp_use.middleware.metrics import create_combined_analytics_middleware

# All-in-one analytics
analytics_mw, get_analytics = create_combined_analytics_middleware()

# Get comprehensive report
report = get_analytics()
print(f"Metrics: {report['metrics']}")
print(f"Performance: {report['performance']}")
print(f"Errors: {report['errors']}")
```

</CodeGroup>

## Middleware Chain Execution

Middleware is executed in the order provided:

```python
middleware = [
    middleware_1,  # Executes first (outermost)
    middleware_2,  # Executes second
    middleware_3,  # Executes third (innermost)
]
```

Execution flow:
1. `middleware_1` starts → calls `call_next()`
2. `middleware_2` starts → calls `call_next()`
3. `middleware_3` starts → calls `call_next()`
4. **Actual MCP call executes**
5. `middleware_3` finishes ← receives result
6. `middleware_2` finishes ← receives result
7. `middleware_1` finishes ← receives result

## Error Handling

Middleware can handle and transform errors:

```python
async def error_handling_middleware(request: MCPRequestContext, call_next: NextFunctionT) -> Any:
    try:
        return await call_next()
    except ConnectionError as e:
        # Log error and retry logic
        print(f"🔄 Connection error for {request.method}, retrying...")
        # Implement retry logic here
        raise
    except Exception as e:
        # Log all errors with context
        print(f"❌ Error in {request.method}: {e}")
        # Add error to metadata
        request.metadata["error"] = str(e)
        raise
```

## Best Practices

### 1. Always Re-raise Exceptions
Unless you're intentionally handling/transforming errors, always re-raise:

```python
async def middleware(request, call_next):
    try:
        return await call_next()
    except Exception as e:
        # Log or process the error
        logger.error(f"Error: {e}")
        raise  # Important: re-raise to maintain error flow
```

### 2. Use Type Hints
Leverage the Protocol types for better IDE support:

```python
async def typed_middleware(
    request: MCPRequestContext,
    call_next: NextFunctionT
) -> Any:
    # IDE provides full autocomplete and type checking
    print(f"Method: {request.method}")
    return await call_next()
```

### 3. Keep Middleware Focused
Each middleware should have a single responsibility:

```python
# Good: Single purpose
async def timing_middleware(request, call_next): ...
async def logging_middleware(request, call_next): ...

# Avoid: Multiple responsibilities in one middleware
async def kitchen_sink_middleware(request, call_next): ...
```

### 4. Use Metadata for Communication
Pass data between middleware using `request.metadata`:

```python
async def auth_middleware(request, call_next):
    request.metadata["user"] = get_current_user()
    return await call_next()

async def audit_middleware(request, call_next):
    user = request.metadata.get("user", "unknown")
    log_audit(user, request.method)
    return await call_next()
```

## Integration with MCP Clients

### MCPClient Integration

```python
from mcp_use import MCPClient

client = MCPClient(
    config={
        "mcpServers": {
            "my_server": {
                "command": "my-mcp-server",
                "args": ["--port", "8080"]
            }
        }
    },
    middleware=[
        logging_middleware,
        metrics_middleware,
        custom_middleware
    ]
)
```

### Per-Session vs Global Middleware

Middleware is configured per-client, allowing different middleware stacks for different use cases:

```python
# Production client with full monitoring
prod_client = MCPClient(
    config=prod_config,
    middleware=[security_middleware, logging_middleware, metrics_middleware]
)

# Development client with just logging
dev_client = MCPClient(
    config=dev_config,
    middleware=[logging_middleware]
)
```

<Note>
See the [examples directory](../../examples/) for complete working examples:
- [`browser_use.py`](../../examples/browser_use.py) - Browser automation with middleware
- [`example_middleware_logging.py`](../../example_middleware_logging.py) - Comprehensive logging examples
</Note>
